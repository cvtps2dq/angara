# Angara

## Язык, ориентированный на IoT и встроенные системы

### Ниже указана спецификация языка на момент его релиза. Чтобы узнать что готово, а что нет - листайте ниже этого гайдлайна.

### Легковесный и эффективный:

Сфокусирован на производительности и эффективности использования памяти для ограниченных ресурсов IoT-устройств.

### Синтаксис, вдохновленный C:

Инкорпорирует некоторые сильные стороны C, предлагая более современный и читаемый синтаксис.

### Конкуренция и обработка событий:

Встроенные абстракции для управления реальными событиями и обработки конкуренции в IoT-устройствах.

### Управление памятью:

Сочетает ручное и автоматическое управление памятью, предоставляя разработчикам контроль и сохраняя безопасность.

## Синтаксис определения функций

Пример функции:
```
function <name>(arguments) returns <data type> { body }
```

### Функция с обработкой ошибок:
```
function <name>(arguments) returns <data type> | throws <error type> { body }
```

## Основные функции языка

###	Абстракции конкуренции:

Упрощенный синтаксис для обработки событий или параллельных задач, например:
```
task sensor_task { 
    loop { 
        read_sensor(); 
        delay(1000); 
    }
}
```
### Прямой доступ к аппаратным средствам:

Легкий доступ к аппаратным регистрам с читаемым синтаксисом, например:
```
register PWM_CONTROL at 0x4001_0000; PWM_CONTROL.set_bits(ENABLE | MODE_FAST);
```

###	Управление памятью:

Поддерживает как ручное, так и автоматическое управление памятью, например:
```
def buffer as int8[256] = allocate();
def data as DataStruct = new DataStruct();.
```

## Синтаксис подключения библиотек/модулей

Используйте ключевое слово attach, чтобы включить внешние библиотеки или модули:
```
attach device::temperature_sensor; attach network::mqtt;
```

## Синтаксис создания переменных

Используйте define для создания переменных:
```
def <var_name> as <data_type>  = <value>;
```

## Типы данных:

Целочисленные типы данных в Angara:

	int8: 8-битное знаковое целое число.
    int16: 16-битное знаковое целое число.
    int32: 32-битное знаковое целое число.
    int64: 64-битное знаковое целое число.

Типы данных с плавающей точкой в Angara:

    float: Представляет одноточечное (32-битное) число с плавающей точкой,
        подходящее для большинства расчетов с умеренной точностью.
    double: Представляет двуточечное (64-битное) число с плавающей точкой,
        обеспечивающее большую точность для расчетов, требующих этого.

Типы данных символов и строк в Angara:

	char: Represents a single character,
    useful for individual letters, digits, or symbols.
	string: Represents a sequence of characters, 
    ideal for text and messages.

## Определение структур в Angara

```
struct <StructName> {
    field1 as dataType1,
    field2 as dataType2,
    // Add more fields as needed
}
```

### Создание и использование структур:

Вы можете создать экземпляр структуры и получить доступ к ее полям следующим образом:

```
def reading = SensorData(25.0, 60, "2024-09-28T12:00:00Z");

// Accessing struct fields
def temp as float = reading.temperature;
def hum as float = reading.humidity;
```

## Передача и ссылка данных:

Когда речь идет о передаче данных в функции и из них, особенно в контексте встроенных систем и IoT, эффективность и контроль за использованием памяти имеют критическое значение.

1.	Передача по значению (копия):

Это способ передачи данных по умолчанию, когда функция получает копию аргумента. Изменения в аргументе внутри функции не влияют на оригинальную переменную. Это просто, но может быть неэффективно для больших структур данных.

Случай использования: Когда работаешь с небольшими, простыми типами данных, такими как целые числа или числа с плавающей точкой.

```
function add(a as int32, b as int32) returns int32 {
    return a + b;
}

def result = add(10, 20); // Pass by value
```

2.	Передача по ссылке (указатель):

Вместо передачи фактических данных мы передаем ссылку (или указатель) на данные. Это более эффективно для больших структур данных и позволяет функции изменять оригинальные данные. Однако это вводит сложность, так как нужно управлять памятью и обеспечивать корректность ссылок.

Случай использования: Когда работаешь с большими структурами данных, структурами или массивами.

```
function modifyValue(ptr as *int32) {
    *ptr = *ptr + 10; // Dereference the pointer to modify the original value
}

def value = int32(5);
modifyValue(&value); // Pass by reference (pointer)
```

3.	Передача по ссылке (без указателя):

Некоторые языки позволяют передавать по ссылке без явных указателей. Функция может изменять аргумент напрямую, но синтаксис становится чище, так как не нужно иметь дело с указателями.

Случай использования: Когда вы хотите, чтобы функция изменила оригинальные данные без сложности указателей.

```
function modifyValue(ref a as int32) {
    a = a + 10;
}

def value = int32(5);
modifyValue(value); // Pass by reference without using pointers
```

4.	Возврат нескольких значений (кортежи или структуры):

Вместо использования указателей для изменения данных, другой вариант — вернуть несколько значений из функции, используя кортежи или структуры. Это может исключить необходимость в указателях в некоторых случаях, при этом позволяя передавать сложные данные внутрь и наружу функции.

Случай использования: Когда нужно вернуть несколько результатов из функции.

```
function getData() returns (int32, int32) {
    return (25, 60); // Returns temperature and humidity
}

def (temp, hum) = getData(); // Multiple value return
```

## Логика - условия

1.	Условный оператор If-Else:

Конструкция if-else позволяет выполнять условные ветвления на основе логических выражений.

```
if (condition) {
    // Code to execute if condition is true
} else if (another_condition) {
    // Code to execute if another_condition is true
} else {
    // Code to execute if no conditions are true
}
```

```
def temperature = int32(30);

if (temperature > 25) {
    print("It's hot.");
} else if (temperature < 15) {
    print("It's cold.");
} else {
    print("The temperature is moderate.");
}
```

2.	Оператор Switch

Оператор switch используется для выбора одного из многих блоков кода для выполнения на основе значения выражения.
Он особенно эффективен для обработки множества дискретных значений, например, для обработки различных состояний или режимов устройства.

```
switch (expression) {
    case value1: {
        // Code for value1
        break;
    }
    case value2: {
        // Code for value2
        break;
    }
    default: {
        // Code if no cases match
    }
}
```

```
def mode = int32(1);

switch (mode) {
    case 0: {
        print("Device is off.");
        break;
    }
    case 1: {
        print("Device is in standby.");
        break;
    }
    case 2: {
        print("Device is active.");
        break;
    }
    default: {
        print("Unknown mode.");
    }
}
```

## Обработка ошибок в Angara:

1.	Throws в сигнатуре функции

Вы можете определить функции, которые могут вызывать ошибки, используя предложение throws в сигнатуре функции,
указывая, что функция может вызвать ошибку во время выполнения.

```
function <name>(arguments) returns <returnType> | throws <ErrorType> { 
    // Body 
}
```

```
function readFile(filePath as string) returns string | throws FileNotFoundError {
    // Code to read file
}
```

2. Блок Try-Catch

Блок try-catch позволяет обрабатывать ошибки контролируемым образом,
давая программе возможность восстанавливаться или адекватно реагировать на ошибку.

```
try {
    // Code that may throw an error
} catch (ErrorType) {
    // Handle the error
} finally {
    // (Optional) code that will always execute, for cleanup
}
```

```
try {
    def data = readFile("config.txt");
    print("File read successfully.");
} catch (FileNotFoundError) {
    print("Error: File not found.");
} catch (PermissionDeniedError) {
    print("Error: Permission denied.");
} finally {
    print("Execution completed.");
}
```

## Безопасность типов в Angara

1.	Сильная типизация:

В Angara переменные и параметры функций должны иметь явно объявленные типы.
Это предотвращает случайные несоответствия типов, например, передачу строки вместо ожидаемого целого числа.
Тип переменной проверяется на этапе компиляции для обеспечения корректности.

```
define <variableName> as <dataType> = <initialValue>;
```

```
define temp as int32 = 25;         // temp is defined as an int32
define greeting as string = "Hi!"; // greeting is defined as a string
```

2.	Вывод типов:

Для упрощения Angara включает ограниченный вывод типов в определенных случаях, когда тип очевиден из контекста.
Тем не менее, явная типизация все еще будет основным вариантом для поддержания ясности.

```
define temp = int32(25);  // Type inferred from int32 constructor
```

3.	Сигнатуры функций с безопасностью типов:

При определении функций необходимо указывать как типы параметров, так и типы возвращаемых значений.
Функция будет принимать только аргументы правильных типов и гарантировать, что будет возвращен правильный тип.

```
function multiply(a as int32, b as int32) returns int32 {
    return a * b;
}
```

4.	Преобразование типов (приведение):

Иногда необходимо преобразовать значения между типами.
В Angara требуется явное приведение, чтобы конвертировать значение из одного типа в другой, предотвращая непреднамеренные неявные преобразования.

```
define temp as int32 = 25;
define precise_temp as float = temp to float;  // Cast int32 to float
```

	5.	Ошибки типов:

Если предоставлен неправильный тип или попытка выполнения операции над несовместимыми типами,
Angara предоставит четкие сообщения об ошибках во время компиляции, указывая на точное место, где возникла проблема.

```
define temperature as float = 25.5;
define mode as int32 = 2;

if (temperature == mode) {
    // Error: Comparison between float and int32 is not allowed
}
```

## Что реализованно:
1. Декларация переменных с базовыми типами.


